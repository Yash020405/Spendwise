# CD Pipeline - Deploy to Kubernetes
name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/spendwise-server

jobs:
  # Stage 1: Deploy
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
      - name: Deploy to K8s
        run: |
          ssh -i ~/.ssh/deploy_key ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            echo "[1/4] Checking Minikube status..."
            minikube status || minikube start --driver=docker --force
            
            echo "[2/4] Rolling update..."
            kubectl rollout restart deployment/spendwise-server -n spendwise
            
            echo "[3/4] Waiting for rollout..."
            kubectl rollout status deployment/spendwise-server -n spendwise --timeout=180s
            
            echo "[4/4] Deployment status:"
            kubectl get pods -n spendwise
          EOF

  # Stage 2: Verify
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    steps:
      - name: Health Check with Retry
        run: |
          echo "Waiting for deployment to stabilize..."
          MAX_RETRIES=6
          RETRY_INTERVAL=15
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            if curl -sf --max-time 10 http://${{ secrets.EC2_HOST }}:3000/api/health; then
              echo ""
              echo "Health check passed on attempt $i"
              exit 0
            fi
            echo "Attempt $i failed, waiting ${RETRY_INTERVAL}s..."
            sleep $RETRY_INTERVAL
          done
          
          echo "Health check failed after $MAX_RETRIES attempts"
          exit 1

  # Stage 3: DAST - Security Testing via SSH
  dast-scan:
    name: DAST Security Scan
    runs-on: ubuntu-latest
    needs: [verify]
    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
      
      - name: Run DAST Security Tests
        run: |
          ssh -i ~/.ssh/deploy_key ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            
            echo "=== Starting DAST (Dynamic Application Security Testing) ==="
            echo "Target: Spendwise Server on Kubernetes"
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            
            # Wait for any terminating pods to complete
            echo "Waiting for rollout to stabilize..."
            kubectl rollout status deployment/spendwise-server -n spendwise --timeout=120s || true
            sleep 10
            
            # Use port-forward service (running on port 3000) or minikube IP for NodePort
            MINIKUBE_IP=$(minikube ip 2>/dev/null || echo "localhost")
            NODE_PORT=$(kubectl get service spendwise-server -n spendwise -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30000")
            
            # Try port-forward first (localhost:3000), fallback to minikube NodePort
            if curl -sf --max-time 5 "http://localhost:3000/api/health" >/dev/null 2>&1; then
              APP_URL="http://localhost:3000"
              echo "Using port-forward: ${APP_URL}"
            else
              APP_URL="http://${MINIKUBE_IP}:${NODE_PORT}"
              echo "Using NodePort: ${APP_URL}"
            fi
            
            echo "Testing application at: ${APP_URL}"
            
            # Verify pod is running
            echo ""
            echo "=== Kubernetes Pod Status ==="
            kubectl get pods -n spendwise -o wide
            POD_STATUS=$(kubectl get pods -n spendwise -l app=spendwise -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "Unknown")
            echo "Pod Status: ${POD_STATUS}"
            
            if [ "$POD_STATUS" != "Running" ]; then
              echo "ERROR: Pod is not in Running state"
              exit 1
            fi
            echo ""
            
            # Test 1: Health endpoint accessibility with retry
            echo "=== Test 1: Health Check ==="
            HEALTH_OK=false
            for attempt in 1 2 3 4 5; do
              echo "Health check attempt $attempt..."
              if curl -sf --max-time 10 "${APP_URL}/api/health" > /tmp/health_response.json 2>/dev/null; then
                echo "✓ Health endpoint accessible"
                echo "Response: $(cat /tmp/health_response.json)"
                HEALTH_OK=true
                break
              fi
              echo "Attempt $attempt failed, waiting 10s..."
              sleep 10
            done
            
            if [ "$HEALTH_OK" != "true" ]; then
              echo "✗ Health endpoint failed after 5 attempts"
              exit 1
            fi
            echo ""
            
            # Test 2: Security Headers Check
            echo "=== Test 2: Security Headers Analysis ==="
            curl -sI --max-time 10 "${APP_URL}/api/health" > /tmp/headers.txt 2>/dev/null || true
            
            SECURITY_SCORE=0
            TOTAL_CHECKS=6
            
            if grep -qi "x-content-type-options" /tmp/headers.txt; then
              echo "✓ X-Content-Type-Options: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "✗ X-Content-Type-Options: MISSING (prevents MIME-type sniffing)"
            fi
            
            if grep -qi "x-frame-options" /tmp/headers.txt; then
              echo "✓ X-Frame-Options: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "✗ X-Frame-Options: MISSING (prevents clickjacking)"
            fi
            
            if grep -qi "x-dns-prefetch-control" /tmp/headers.txt; then
              echo "✓ X-DNS-Prefetch-Control: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "✗ X-DNS-Prefetch-Control: MISSING"
            fi
            
            if grep -qi "strict-transport-security" /tmp/headers.txt; then
              echo "✓ Strict-Transport-Security: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "⚠ Strict-Transport-Security: MISSING (HSTS recommended for HTTPS)"
            fi
            
            if grep -qi "content-security-policy" /tmp/headers.txt; then
              echo "✓ Content-Security-Policy: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "✗ Content-Security-Policy: MISSING (prevents XSS attacks)"
            fi
            
            if grep -qi "x-xss-protection" /tmp/headers.txt; then
              echo "✓ X-XSS-Protection: present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "⚠ X-XSS-Protection: MISSING (legacy XSS protection)"
            fi
            
            echo ""
            echo "Security Headers Score: ${SECURITY_SCORE}/${TOTAL_CHECKS}"
            echo ""
            
            # Test 3: API Response Validation
            echo "=== Test 3: API Response Validation ==="
            RESPONSE=$(curl -s --max-time 10 "${APP_URL}/api/health" 2>/dev/null || echo "{}")
            echo "Response content: ${RESPONSE}"
            
            if echo "$RESPONSE" | grep -q "status"; then
              echo "✓ Valid JSON response with status field"
            else
              echo "⚠ Response format unexpected"
            fi
            echo ""
            
            # Test 4: 404 Handling
            echo "=== Test 4: Error Handling (404) ==="
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${APP_URL}/nonexistent" 2>/dev/null || echo "000")
            echo "Non-existent route returns: HTTP ${STATUS}"
            
            if [ "$STATUS" = "404" ] || [ "$STATUS" = "301" ]; then
              echo "✓ Proper 404 error handling"
            else
              echo "⚠ Unexpected status code: ${STATUS}"
            fi
            echo ""
            
            # Test 5: Server Information Disclosure
            echo "=== Test 5: Server Information Disclosure ==="
            if grep -qi "^server:" /tmp/headers.txt; then
              SERVER_HEADER=$(grep -i "^server:" /tmp/headers.txt | head -n1)
              echo "⚠ Server header present: ${SERVER_HEADER}"
              echo "  Recommendation: Remove or obfuscate server version information"
            else
              echo "✓ Server header not exposed"
            fi
            echo ""
            
            # Test 6: HTTP Methods Allowed
            echo "=== Test 6: Allowed HTTP Methods ==="
            METHODS=$(curl -sI -X OPTIONS --max-time 10 "${APP_URL}/api/health" 2>/dev/null | grep -i "allow:" || echo "Not disclosed")
            echo "Allowed methods: ${METHODS}"
            echo ""
            
            # Test 7: Rate Limiting (Basic Check)
            echo "=== Test 7: Rate Limiting Test ==="
            echo "Sending 5 rapid requests..."
            for i in {1..5}; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "${APP_URL}/api/health" 2>/dev/null || echo "000")
              echo "Request $i: HTTP ${STATUS}"
            done
            echo "Note: No 429 (Too Many Requests) - Rate limiting may not be configured"
            echo ""
            
            # Final Summary
            echo "=== DAST Security Scan Summary ==="
            echo "✓ Application is accessible and responsive"
            echo "✓ Health endpoint working correctly"
            echo "  Security Headers: ${SECURITY_SCORE}/${TOTAL_CHECKS} implemented"
            echo ""
            echo "=== DAST Scan Completed Successfully ==="
            
            # Cleanup
            rm -f /tmp/headers.txt /tmp/health_response.json
          EOF

  # Stage 4: Rollback (on failure)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy, verify]
    if: failure()
    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
      - name: Rollback
        run: |
          ssh -i ~/.ssh/deploy_key ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            kubectl rollout undo deployment/spendwise-server -n spendwise
            kubectl rollout status deployment/spendwise-server -n spendwise --timeout=120s
          EOF
